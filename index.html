<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>因數泡泡龍 | 數學大師版</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Noto+Sans+TC:wght@400;700&display=swap');
        
        body {
            font-family: 'Noto Sans TC', sans-serif;
            overflow: hidden;
            background-color: #0f172a;
            touch-action: none;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
        }

        #ui-layer { z-index: 10; pointer-events: none; }
        .pointer-events-auto { pointer-events: auto; }

        .game-btn {
            transition: transform 0.1s, box-shadow 0.1s;
        }
        .game-btn:active {
            transform: scale(0.95);
        }

        @keyframes rainbow-border {
            0% { border-color: #ef4444; }
            20% { border-color: #eab308; }
            40% { border-color: #22c55e; }
            60% { border-color: #3b82f6; }
            80% { border-color: #a855f7; }
            100% { border-color: #ef4444; }
        }
        .rainbow-border { animation: rainbow-border 2s linear infinite; }

        @keyframes pulse-text {
            0%, 100% { opacity: 1; transform: scale(1); }
            50% { opacity: 0.8; transform: scale(0.95); }
        }
        .pulse-text { animation: pulse-text 2s ease-in-out infinite; }
        
        @keyframes flash-red {
            0%, 100% { background-color: transparent; }
            50% { background-color: rgba(239, 68, 68, 0.3); }
        }
        .warning-bg { animation: flash-red 0.5s infinite; }

        /* 因數教學彈窗樣式 - 鮮豔配色 */
        .factor-pair { font-weight: 900; text-shadow: 0 1px 2px rgba(0,0,0,0.5); }
        .factor-color-0 { color: #ff6b6b; } 
        .factor-color-1 { color: #4ecdc4; } 
        .factor-color-2 { color: #ffe66d; } 
        .factor-color-3 { color: #a29bfe; } 
        .factor-color-4 { color: #ff9ff3; } 
        .factor-color-5 { color: #54a0ff; } 
    </style>
</head>
<body class="w-full h-full fixed inset-0 text-white">

    <canvas id="gameCanvas" class="absolute top-0 left-0 w-full h-full block"></canvas>

    <div id="effectOverlay" class="absolute inset-0 pointer-events-none z-20"></div>

    <div id="timerBarContainer" class="absolute right-0 top-0 bottom-0 w-1.5 md:w-2 bg-gray-800/50 z-5 pointer-events-none hidden">
        <div id="timerBar" class="w-full bg-red-600 absolute bottom-0 transition-all duration-100 ease-linear shadow-[0_0_10px_rgba(220,38,38,0.8)]"></div>
    </div>

    <!-- UI 層 -->
    <div id="ui-layer" class="absolute top-0 left-0 w-full h-full flex flex-col justify-between p-2 md:p-4 safe-area-inset">
        
        <!-- 頂部按鈕 -->
        <div class="flex justify-between items-start w-full pointer-events-none">
            <div class="flex gap-2 pointer-events-auto">
                <button id="homeBtn" class="bg-blue-600/80 hover:bg-blue-500 text-white p-2 rounded-lg border border-blue-400 shadow-lg backdrop-blur">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 md:h-6 md:w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3 12l2-2m0 0l7-7 7 7M5 10v10a1 1 0 001 1h3m10-11l2 2m-2-2v10a1 1 0 01-1 1h-3m-6 0a1 1 0 001-1v-4a1 1 0 011-1h2a1 1 0 011 1v4a1 1 0 001 1m-6 0h6" />
                    </svg>
                </button>
                <button id="musicBtn" class="bg-purple-600/80 hover:bg-purple-500 text-white p-2 rounded-lg border border-purple-400 shadow-lg backdrop-blur opacity-50 transition-opacity">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 md:h-6 md:w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15.536 8.464a5 5 0 010 7.072m2.828-9.9a9 9 0 010 12.728M5.586 15H4a1 1 0 01-1-1v-4a1 1 0 011-1h1.586l4.707-4.707C10.923 3.663 12 4.109 12 5v14c0 .891-1.077 1.337-1.707.707L5.586 15z" />
                    </svg>
                </button>
                <button id="restartLevelBtn" class="bg-gray-700/80 hover:bg-gray-600 text-white font-bold py-2 px-3 md:px-4 rounded-lg border border-gray-500 shadow-lg text-xs md:text-sm backdrop-blur flex items-center gap-2">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15" />
                    </svg>
                    <span class="hidden sm:inline">本關重來</span>
                </button>
            </div>
            
            <div id="statusMessage" class="hidden md:flex bg-black/60 backdrop-blur px-4 py-2 rounded-lg border border-yellow-500/30 text-yellow-300 text-sm font-bold items-center justify-center pulse-text absolute left-1/2 transform -translate-x-1/2 top-2 md:top-4 pointer-events-none whitespace-nowrap">
                射擊因數消除題目！
            </div>
        </div>

        <!-- 底部資訊與發射台 -->
        <div class="relative w-full flex-grow flex flex-col justify-end pointer-events-none">
            
            <div class="absolute bottom-20 md:bottom-4 left-0 bg-gray-800/90 backdrop-blur rounded-xl p-2 md:p-3 border border-blue-500/50 shadow-lg min-w-[80px] md:min-w-[100px] z-30 transform scale-90 md:scale-100 origin-bottom-left">
                <div class="text-[10px] md:text-xs text-blue-300 uppercase tracking-wider">Score</div>
                <div id="scoreDisplay" class="text-xl md:text-2xl font-bold text-white font-mono">0</div>
            </div>

            <div class="absolute bottom-20 md:bottom-4 right-0 bg-gray-800/90 backdrop-blur rounded-xl p-2 md:p-3 border border-red-500/50 shadow-lg min-w-[80px] md:min-w-[100px] text-right z-30 transform scale-90 md:scale-100 origin-bottom-right">
                <div class="text-[10px] md:text-xs text-red-300 uppercase tracking-wider">Level</div>
                <div id="levelDisplay" class="text-xl md:text-2xl font-bold text-white font-mono">1/5</div>
            </div>

            <!-- 發射區 -->
            <div class="relative w-full max-w-lg mx-auto flex flex-col items-center justify-end pb-2 md:pb-4" style="height: 20vh; min-height: 120px; max-height: 180px;">
                <div id="hintText" class="mb-2 md:mb-4 text-center text-gray-300 font-bold text-xs md:text-sm drop-shadow-md bg-black/50 px-3 py-1 rounded-full transition-opacity duration-300 z-10 whitespace-nowrap">
                    目標：湊齊所有因數
                </div>

                <div id="cannonBase" class="relative z-20 flex flex-col items-center justify-center transform scale-75 md:scale-100 origin-bottom">
                    <div id="cannonBarrel" class="absolute w-24 h-24 rounded-full border-4 border-gray-500 opacity-20 pointer-events-none"></div>
                    <div class="relative group cursor-pointer pointer-events-auto">
                        <div class="absolute inset-0 bg-white blur-xl opacity-20 rounded-full animate-pulse"></div>
                        <div id="currentAmmoBall" class="relative w-20 h-20 bg-[conic-gradient(at_top,_var(--tw-gradient-stops))] from-red-500 via-yellow-500 via-green-500 via-blue-500 to-red-500 rounded-full border-4 border-white/50 flex items-center justify-center shadow-2xl transition-transform hover:scale-105 active:scale-95 rainbow-border">
                            <div id="ammoDisplay" class="text-4xl font-black text-white drop-shadow-[0_2px_2px_rgba(0,0,0,0.8)]">?</div>
                        </div>
                    </div>
                    <div class="absolute right-[-60px] bottom-0 w-12 h-12 bg-gray-800 rounded-full border-2 border-gray-600 flex items-center justify-center opacity-80 scale-90 origin-left">
                        <span class="text-[10px] absolute -top-4 text-gray-400">Next</span>
                        <span id="nextAmmoDisplay" class="font-bold text-white">?</span>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- 因數教學彈窗 -->
    <div id="factorInfoScreen" class="hidden absolute inset-0 z-40 flex items-center justify-center bg-gray-900/95 backdrop-blur-md pointer-events-auto p-4">
        <div class="bg-gray-800 p-6 md:p-8 rounded-2xl border border-gray-600 max-w-md w-full text-center shadow-2xl relative overflow-hidden">
            <div class="absolute top-0 left-0 w-full h-2 bg-gradient-to-r from-blue-500 via-purple-500 to-pink-500"></div>
            <h2 class="text-2xl md:text-3xl font-bold text-white mb-6">
                消除成功! <span id="infoBaseNum" class="text-yellow-400 text-4xl ml-2 font-mono"></span>
            </h2>
            
            <div class="bg-gray-900/50 rounded-xl p-4 mb-6 text-left border border-gray-700">
                <div class="text-xs md:text-sm text-gray-400 mb-2 uppercase tracking-wide text-center">因數分解對應</div>
                <div id="infoPairs" class="text-xl md:text-2xl space-y-3 font-mono text-center">
                    <!-- JS 動態生成內容 -->
                </div>
            </div>

            <div id="infoList" class="text-lg md:text-xl text-gray-300 mb-8 bg-gray-700/30 p-4 rounded-lg">
                <!-- JS 動態生成內容 -->
            </div>

            <button id="infoContinueBtn" class="game-btn bg-blue-600 hover:bg-blue-500 text-white font-bold py-3 px-8 rounded-full text-lg shadow-lg w-full md:w-auto">
                明白! 繼續挑戰
            </button>
        </div>
    </div>

    <!-- Start Screen -->
    <div id="startScreen" class="absolute inset-0 z-30 flex items-center justify-center bg-gray-900/90 backdrop-blur-md pointer-events-auto p-4">
        <div class="text-center max-w-md w-full bg-gray-800/80 p-6 md:p-8 rounded-2xl border border-gray-700 shadow-2xl">
            <h1 class="text-4xl md:text-6xl font-black text-transparent bg-clip-text bg-gradient-to-r from-yellow-400 via-orange-500 to-red-500 mb-6 tracking-tight">
                因數<br>泡泡龍
            </h1>
            <div class="space-y-4 text-left mb-8">
                <div class="flex items-center">
                    <div class="w-8 h-8 rounded-full bg-red-600 flex items-center justify-center mr-3 shrink-0 font-bold text-xs border-2 border-white">6</div>
                    <p class="text-gray-200 text-sm">白框是題目，請射擊它的<span class="text-yellow-300 font-bold">因數</span>。</p>
                </div>
                <div class="flex items-center">
                    <div class="w-8 h-8 rounded-full bg-blue-600 flex items-center justify-center mr-3 shrink-0 font-bold text-xs">!</div>
                    <p class="text-gray-200 text-sm">系統會自動提供需要的數字。</p>
                </div>
                <div class="flex items-center">
                    <div class="w-8 h-8 rounded-full bg-gray-600 flex items-center justify-center mr-3 shrink-0 font-bold text-xs">5</div>
                    <p class="text-gray-200 text-sm">共 <span class="text-red-400 font-bold">5 關</span>，難度逐漸提升。</p>
                </div>
            </div>
            <button id="startBtn" class="w-full game-btn bg-gradient-to-r from-blue-600 to-purple-600 hover:from-blue-500 hover:to-purple-500 text-white font-bold py-4 rounded-xl text-xl shadow-lg border-2 border-white/20">
                點擊開始
            </button>
        </div>
    </div>

    <!-- Victory Screen -->
    <div id="victoryScreen" class="hidden absolute inset-0 z-30 flex items-center justify-center bg-gray-900/90 backdrop-blur-md pointer-events-auto p-4">
        <div class="text-center max-w-md w-full">
            <h1 class="text-5xl md:text-6xl font-black text-transparent bg-clip-text bg-gradient-to-r from-green-300 via-yellow-300 to-pink-300 mb-4 filter drop-shadow-lg">
                恭喜通關!
            </h1>
            <p class="text-white text-lg md:text-xl mb-8">你已經是因數大師了！</p>
            <div class="text-sm text-gray-400 mb-2">最終總分</div>
            <div class="text-6xl md:text-7xl font-black text-white mb-8" id="victoryScore">0</div>
            <button id="restartGameBtn" class="game-btn bg-green-600 hover:bg-green-500 text-white font-bold py-3 px-10 rounded-full text-lg shadow-lg w-full md:w-auto">
                重新挑戰
            </button>
        </div>
    </div>

    <!-- Game Over Screen -->
    <div id="gameOverScreen" class="hidden absolute inset-0 z-30 flex items-center justify-center bg-gray-900/90 backdrop-blur-md pointer-events-auto p-4">
        <div class="text-center max-w-md w-full">
            <h2 class="text-4xl md:text-5xl font-bold text-red-500 mb-4">挑戰失敗</h2>
            <div class="text-sm text-gray-400 mb-6">泡泡碰到底線了...</div>
            <div class="text-sm text-gray-400 mb-2">最終得分</div>
            <div class="text-6xl md:text-7xl font-black text-white mb-8" id="finalScore">0</div>
            <div class="flex flex-col md:flex-row gap-4 justify-center">
                <button id="backToMenuBtn" class="game-btn bg-gray-600 hover:bg-gray-500 text-white font-bold py-3 px-6 rounded-full text-lg shadow-lg">
                    主選單
                </button>
                <button id="restartBtn" class="game-btn bg-green-600 hover:bg-green-500 text-white font-bold py-3 px-10 rounded-full text-lg shadow-lg">
                    再玩一次
                </button>
            </div>
        </div>
    </div>

    <script>
        // --- 全域變數定義區 ---
        let audioCtx = null;
        let isMusicPlaying = false;
        let bgmOscillators = [];
        
        let gameState = 'MENU';
        let score = 0;
        let level = 1;
        
        let grid = [];
        let projectile = null;
        let currentAmmo = 2;
        let nextAmmo = 3;
        
        let dropTimer = 0;
        let dropInterval = 30000; // 初始 30秒 (Level 1)
        let gridOffset = 0;
        let ceilingRow = 0;
        
        let pendingClearData = null;
        
        let cw, ch, radius, tileWidth, tileHeight, gridOffsetX, gridOffsetY, cannonPos;
        let aimAngle = -Math.PI / 2;
        let isAiming = false;

        let particles = [];
        let floatTexts = [];
        let stars = [];
        let shakeTime = 0;
        
        let lastTime = 0;

        // --- Audio System ---
        function initAudioContext() {
            if (!audioCtx) {
                const AudioContext = window.AudioContext || window.webkitAudioContext;
                if (AudioContext) audioCtx = new AudioContext();
            }
            if (audioCtx && audioCtx.state === 'suspended') audioCtx.resume();
        }

        document.addEventListener('click', initAudioContext);
        document.addEventListener('touchstart', initAudioContext);

        // --- Config ---
        const config = {
            cols: 8,            
            rows: 11,           
            initialRows: 1,
            colors: {
                bg: '#111827',
                aimLine: 'rgba(255, 255, 255, 0.5)',
                bubbles: ['#ef4444', '#f97316', '#eab308', '#22c55e', '#06b6d4', '#3b82f6', '#8b5cf6', '#ec4899']
            },
            projSpeed: 2000,
            maxLevels: 5
        };

        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        const els = {
            score: document.getElementById('scoreDisplay'),
            level: document.getElementById('levelDisplay'),
            ammo: document.getElementById('ammoDisplay'),
            nextAmmo: document.getElementById('nextAmmoDisplay'),
            ammoBall: document.getElementById('currentAmmoBall'),
            start: document.getElementById('startScreen'),
            gameOver: document.getElementById('gameOverScreen'),
            victory: document.getElementById('victoryScreen'),
            finalScore: document.getElementById('finalScore'),
            victoryScore: document.getElementById('victoryScore'),
            hint: document.getElementById('hintText'),
            status: document.getElementById('statusMessage'),
            timerBar: document.getElementById('timerBar'),
            timerContainer: document.getElementById('timerBarContainer'),
            effect: document.getElementById('effectOverlay'),
            musicBtn: document.getElementById('musicBtn'),
            infoScreen: document.getElementById('factorInfoScreen'),
            infoBaseNum: document.getElementById('infoBaseNum'),
            infoPairs: document.getElementById('infoPairs'),
            infoList: document.getElementById('infoList'),
            infoBtn: document.getElementById('infoContinueBtn')
        };

        // --- Init ---
        window.addEventListener('resize', resize);
        
        document.getElementById('startBtn').addEventListener('click', () => { initAudioContext(); initGame(true); });
        document.getElementById('restartBtn').addEventListener('click', () => initGame(true));
        document.getElementById('restartGameBtn').addEventListener('click', () => initGame(true));
        document.getElementById('restartLevelBtn').addEventListener('click', restartLevel);
        document.getElementById('homeBtn').addEventListener('click', goHome);
        document.getElementById('backToMenuBtn').addEventListener('click', goHome);
        document.getElementById('musicBtn').addEventListener('click', toggleMusic);
        els.infoBtn.addEventListener('click', resumeFromInfo);

        canvas.addEventListener('mousedown', onPointerDown);
        canvas.addEventListener('mousemove', onPointerMove);
        canvas.addEventListener('mouseup', onPointerUp);
        canvas.addEventListener('touchstart', (e) => { e.preventDefault(); onPointerDown(e.touches[0]); }, {passive: false});
        canvas.addEventListener('touchmove', (e) => { e.preventDefault(); onPointerMove(e.touches[0]); }, {passive: false});
        canvas.addEventListener('touchend', (e) => { e.preventDefault(); onPointerUp(e.changedTouches[0]); }, {passive: false});

        resize();
        initStars();
        lastTime = performance.now();
        requestAnimationFrame(gameLoop);

        function resize() {
            const dpr = window.devicePixelRatio || 1;
            const cssW = window.innerWidth;
            const cssH = window.innerHeight;
            canvas.width = cssW * dpr;
            canvas.height = cssH * dpr;
            cw = cssW; ch = cssH;
            ctx.scale(dpr, dpr);

            const maxGridWidth = Math.min(cw, 650);
            const radiusW = (maxGridWidth - 20) / (config.cols * 2 + 1) * 2;
            const safeHeight = ch - 240; 
            const radiusH = safeHeight / (config.rows * 1.5);
            radius = Math.min(radiusW, radiusH);
            
            radius = Math.max(20, Math.min(55, radius)); 

            tileWidth = radius * 2;
            tileHeight = radius * Math.sqrt(3);
            gridOffsetX = (cw - (tileWidth * config.cols + radius)) / 2;
            if (gridOffsetX < 5) gridOffsetX = 5;
            gridOffsetY = 60; 
            cannonPos = { x: cw / 2, y: ch - 120 };
            if (ch < 600) cannonPos.y = ch - 90;
            if(stars.length > 0) initStars();
        }

        function initStars() {
            stars = [];
            const count = Math.floor(cw * ch / 4000);
            for(let i=0; i<count; i++) {
                stars.push({
                    x: Math.random() * cw, y: Math.random() * ch,
                    size: Math.random() * 2 + 0.5,
                    blinkSpeed: Math.random() * 0.05 + 0.01,
                    alpha: Math.random(),
                    dir: Math.random() < 0.5 ? 1 : -1
                });
            }
        }

        function initGame(resetScore = false) {
            initAudioContext();
            if(resetScore) {
                score = 0;
                level = 1;
                isMusicPlaying = true;
                els.musicBtn.classList.remove('opacity-50');
                startBGM();
            }
            gameState = 'PLAYING';
            projectile = null;
            particles = [];
            floatTexts = [];
            dropTimer = 0;
            gridOffset = 0;
            ceilingRow = 0;
            updateDropInterval();
            els.timerContainer.classList.remove('hidden');
            els.start.classList.add('hidden');
            els.gameOver.classList.add('hidden');
            els.victory.classList.add('hidden');
            els.infoScreen.classList.add('hidden');
            generateGrid();
            revalidateAmmo();
            updateUI();
            if (isMusicPlaying) startBGM();
        }

        function goHome() {
            gameState = 'MENU';
            els.start.classList.remove('hidden');
            els.gameOver.classList.add('hidden');
            els.victory.classList.add('hidden');
            els.timerContainer.classList.add('hidden');
            els.effect.classList.remove('warning-bg');
            els.infoScreen.classList.add('hidden');
            stopBGM();
            isMusicPlaying = false;
            els.musicBtn.classList.add('opacity-50');
        }

        function restartLevel() {
            if (gameState !== 'PLAYING') return;
            projectile = null;
            particles = [];
            floatTexts = [];
            dropTimer = 0;
            gridOffset = 0;
            ceilingRow = 0;
            els.effect.classList.remove('warning-bg');
            generateGrid();
            revalidateAmmo();
            addFloatText(cw/2, ch/2, "RESTART", '#fff', 40);
        }
        
        function updateDropInterval() {
            // Level 1: 30s, Level 5: 22s
            dropInterval = Math.max(22000, 30000 - ((level - 1) * 2000));
        }

        function generateGrid() {
            grid = [];
            // 題目數量控制
            let minTargets = 2; 
            let maxTargets = 3; 
            if (level === 2) { minTargets=3; maxTargets=4; }
            if (level >= 3) { minTargets=3; maxTargets=5; }
            if (level === 5) { minTargets=4; maxTargets=6; }
            
            const targetCount = Math.floor(Math.random() * (maxTargets - minTargets + 1)) + minTargets;
            
            let positions = [];
            for (let c = 0; c < config.cols; c++) positions.push(c);
            for (let i = positions.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [positions[i], positions[j]] = [positions[j], positions[i]];
            }
            for (let r = 0; r < config.rows; r++) { 
                grid[r] = [];
                for (let c = 0; c < config.cols; c++) grid[r][c] = null;
            }
            for (let i = 0; i < targetCount; i++) {
                if (i < positions.length) {
                    grid[0][positions[i]] = createBaseBubble();
                }
            }
        }

        function createBaseBubble() {
            let pool;
            // 平滑難度曲線
            if (level <= 1) pool = [4, 6, 8, 9, 10, 12, 14, 15]; 
            else if (level <= 2) pool = [12, 15, 16, 18, 20, 21, 22, 24];
            else if (level <= 3) pool = [24, 25, 26, 27, 28, 30, 32, 33, 35];
            else if (level <= 4) pool = [36, 38, 39, 40, 42, 44, 45, 48, 49];
            else pool = [48, 50, 51, 52, 54, 56, 60, 64];

            const val = pool[Math.floor(Math.random() * pool.length)];
            const colorIdx = Math.floor(Math.random() * config.colors.bubbles.length);
            return { val: val, baseNum: val, colorIdx: colorIdx, popAnim: 0 };
        }

        function getFactors(num) {
            const f = [];
            for(let i=1; i<=num; i++) if(num % i === 0) f.push(i);
            return f;
        }

        function getNeededFactorsSet() {
            let allMissingFactors = new Set();
            let baseNumbersPresent = false;
            let globalVisited = new Set();
            for(let r=ceilingRow; r<grid.length; r++) {
                for(let c=0; c<grid[r].length; c++) {
                    const key = `${r},${c}`;
                    if(globalVisited.has(key)) continue;
                    const b = grid[r][c];
                    if(b && b.baseNum) {
                        baseNumbersPresent = true;
                        const clusterData = getClusterData(r, c, b.baseNum);
                        clusterData.coords.forEach(coord => globalVisited.add(coord));
                        const factors = getFactors(b.baseNum);
                        const presentValues = clusterData.values;
                        factors.forEach(f => {
                            if (f !== b.baseNum && !presentValues.has(f)) allMissingFactors.add(f);
                        });
                    }
                }
            }
            return { set: allMissingFactors, hasTargets: baseNumbersPresent };
        }

        function generateAmmo() {
            const { set, hasTargets } = getNeededFactorsSet();
            if (!hasTargets) { nextAmmo = 2; return; }
            if (set.size > 0) {
                const arr = Array.from(set);
                nextAmmo = arr[Math.floor(Math.random() * arr.length)];
            } else { nextAmmo = 1; }
            updateUI();
        }

        function revalidateAmmo() {
            const { set, hasTargets } = getNeededFactorsSet();
            if (hasTargets && set.size > 0) {
                if (!set.has(currentAmmo)) {
                    const arr = Array.from(set);
                    currentAmmo = arr[Math.floor(Math.random() * arr.length)];
                }
            }
            generateAmmo();
            updateUI();
        }

        function getClusterData(r, c, baseNum) {
            let queue = [{r, c}];
            let coords = new Set();
            let values = new Set();
            const startKey = `${r},${c}`;
            coords.add(startKey);
            if (grid[r][c]) values.add(grid[r][c].val);
            while(queue.length > 0) {
                const curr = queue.shift();
                const neighbors = getNeighbors(curr.r, curr.c);
                for (let n of neighbors) {
                    const key = `${n.r},${n.c}`;
                    if (coords.has(key)) continue;
                    const nb = grid[n.r][n.c];
                    if (nb && nb.baseNum === baseNum) {
                        coords.add(key);
                        values.add(nb.val);
                        queue.push(n);
                    }
                }
            }
            return { coords, values };
        }

        function showFactorInfo(baseNum, clusterCoords) {
            gameState = 'PAUSED_FOR_INFO';
            pendingClearData = { coords: clusterCoords, baseNum: baseNum };
            
            els.infoBaseNum.innerText = baseNum;
            const pairs = [];
            const sqrt = Math.sqrt(baseNum);
            for(let i=1; i<=sqrt; i++) {
                if(baseNum % i === 0) {
                    pairs.push([i, baseNum/i]);
                }
            }
            let pairsHtml = '';
            pairs.forEach((p, idx) => {
                const colorClass = `factor-color-${idx % 6}`; 
                pairsHtml += `
                    <div class="flex justify-center items-center gap-2">
                        <span class="${colorClass} factor-pair">${p[0]}</span> 
                        <span class="text-gray-500">x</span> 
                        <span class="${colorClass} factor-pair">${p[1]}</span>
                        <span class="text-gray-500">=</span>
                        <span class="text-white">${baseNum}</span>
                    </div>`;
            });
            const allFactors = getFactors(baseNum);
            const coloredList = allFactors.map(f => {
                let pIdx = 0;
                pairs.forEach((p, idx) => { if(p[0]===f || p[1]===f) pIdx = idx; });
                return `<span class="factor-color-${pIdx % 6} factor-pair text-2xl mx-1">${f}</span>`;
            });
            els.infoPairs.innerHTML = pairsHtml;
            els.infoList.innerHTML = `所以 <span class="text-yellow-400 font-bold">${baseNum}</span> 的因數有:<br> [ ${coloredList.join(', ')} ]`;
            els.infoScreen.classList.remove('hidden');
            playSound('levelup');
        }

        function resumeFromInfo() {
            els.infoScreen.classList.add('hidden');
            gameState = 'PLAYING';
            if (pendingClearData) {
                const { coords, baseNum } = pendingClearData;
                playSound('pop');
                score += coords.size * 200 + baseNum * 10;
                coords.forEach(key => {
                    const [cr, cc] = key.split(',').map(Number);
                    const b = grid[cr][cc];
                    const p = getBubblePos(cr, cc);
                    spawnParticles(p, config.colors.bubbles[b.colorIdx]);
                    addFloatText(p.x, p.y, b.val, '#fff');
                    grid[cr][cc] = null;
                });
                els.hint.innerText = `完美！${baseNum} 的因數全齊了！`;
                els.hint.className = "mb-4 text-center text-green-400 font-bold text-lg drop-shadow-md z-10";
                removeFloatingBubbles();
                pendingClearData = null;
            }
        }

        function checkFactorCompletion(r, c, baseNum) {
            const clusterData = getClusterData(r, c, baseNum);
            const requiredFactors = getFactors(baseNum);
            const factorsNeeded = requiredFactors.filter(f => f !== baseNum);
            const missing = factorsNeeded.filter(f => !clusterData.values.has(f));

            if (missing.length === 0) {
                showFactorInfo(baseNum, clusterData.coords);
            } else {
                if (level >= 3) {
                    els.hint.innerText = "還未集齊...";
                    els.hint.className = "mb-4 text-center text-gray-400 font-bold text-sm drop-shadow-md z-10 opacity-70";
                } else {
                    els.hint.innerText = `${baseNum} 還缺: ${missing.join(', ')}`;
                    els.hint.className = "mb-4 text-center text-yellow-300 font-bold text-sm drop-shadow-md z-10";
                }
                if (r >= config.rows - 1) gameOver();
            }
        }

        function removeFloatingBubbles() {
            let rooted = new Set();
            let queue = [];
            for(let c=0; c<grid[ceilingRow]?.length || 0; c++) {
                if(grid[ceilingRow][c]) {
                    queue.push({r:ceilingRow, c:c});
                    rooted.add(`${ceilingRow},${c}`);
                }
            }
            while(queue.length > 0) {
                const curr = queue.shift();
                const neighbors = getNeighbors(curr.r, curr.c);
                for (let n of neighbors) {
                    if (grid[n.r][n.c] && !rooted.has(`${n.r},${n.c}`)) {
                        rooted.add(`${n.r},${n.c}`);
                        queue.push(n);
                    }
                }
            }
            for(let r=ceilingRow; r<grid.length; r++) {
                for(let c=0; c<grid[r].length; c++) {
                    if (grid[r][c] && !rooted.has(`${r},${c}`)) {
                        const pos = getBubblePos(r, c);
                        spawnParticles(pos, '#999', 5);
                        grid[r][c] = null;
                        score += 50; 
                    }
                }
            }
            checkLevelComplete();
        }

        function getNeighbors(r, c) {
            const effectiveRowType = (r + gridOffset) % 2; 
            const offsets = (effectiveRowType === 0) 
                ? [[0, -1], [0, 1], [-1, -1], [-1, 0], [1, -1], [1, 0]]
                : [[0, -1], [0, 1], [-1, 0], [-1, 1], [1, 0], [1, 1]];
            const neighbors = [];
            for (let o of offsets) {
                const nr = r + o[0];
                const nc = c + o[1];
                if (nr >= 0 && nr < config.rows && nc >= 0) {
                    const colsInRow = config.cols - ((nr + gridOffset) % 2);
                    if (nc < colsInRow) neighbors.push({r: nr, c: nc});
                }
            }
            return neighbors;
        }

        function onPointerDown(e) { if (gameState !== 'PLAYING') return; isAiming = true; updateAim(e); }
        function onPointerMove(e) { if (!isAiming || gameState !== 'PLAYING') return; updateAim(e); }
        function onPointerUp(e) { if (!isAiming || gameState !== 'PLAYING') return; isAiming = false; shoot(); }

        function updateAim(e) {
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            const dx = x - cannonPos.x;
            const dy = y - cannonPos.y;
            if (dy < 0) {
                aimAngle = Math.atan2(dy, dx);
                const deg = aimAngle * 180 / Math.PI;
                document.getElementById('cannonBase').style.transform = `rotate(${deg + 90}deg)`;
            }
        }

        function shoot() {
            if (projectile) return;
            projectile = {
                x: cannonPos.x, y: cannonPos.y,
                vx: Math.cos(aimAngle) * config.projSpeed,
                vy: Math.sin(aimAngle) * config.projSpeed,
                val: currentAmmo
            };
            playSound('shoot');
            const base = document.getElementById('cannonBase');
            base.style.transition = 'none';
            base.style.transform += ' scale(0.9)';
            setTimeout(() => {
                base.style.transition = 'transform 0.2s';
                base.style.transform = base.style.transform.replace(' scale(0.9)', '');
            }, 50);
        }

        function gameOver() {
            gameState = 'GAMEOVER';
            els.finalScore.innerText = score;
            els.gameOver.classList.remove('hidden');
        }

        function checkLevelComplete() {
            let hasTargets = false;
            for(let r=ceilingRow; r<grid.length; r++) {
                for(let c=0; c<grid[r].length; c++) {
                    if (grid[r][c] && grid[r][c].baseNum) {
                        hasTargets = true;
                        break;
                    }
                }
                if(hasTargets) break;
            }
            if (!hasTargets) levelUp();
        }

        function levelUp() {
            if (level >= config.maxLevels) {
                gameState = 'VICTORY';
                els.victoryScore.innerText = score;
                els.victory.classList.remove('hidden');
                playSound('levelup');
                return;
            }
            score += 2000;
            level++;
            dropTimer = 0; 
            gridOffset = 0;
            ceilingRow = 0;
            els.effect.classList.remove('warning-bg'); 
            addFloatText(cw/2, ch/2, "STAGE CLEAR!", '#fbbf24', 60);
            playSound('levelup');
            setTimeout(() => {
                generateGrid();
                currentAmmo = 2;
                revalidateAmmo();
            }, 1500);
        }

        function dropGrid() {
            const lastRowIdx = config.rows - 1;
            for(let c=0; c<grid[lastRowIdx].length; c++) {
                if (grid[lastRowIdx][c]) {
                    gameOver();
                    return;
                }
            }
            for (let r = config.rows - 2; r >= 0; r--) {
                for (let c = 0; c < config.cols; c++) grid[r+1][c] = grid[r][c];
            }
            for(let c=0; c<config.cols; c++) grid[0][c] = null;
            gridOffset = (gridOffset + 1) % 2; 
            ceilingRow++;
            playSound('drop');
            shakeTime = 0.3;
            addFloatText(cw/2, ch/3, "DOWN!", '#ef4444', 40);
            revalidateAmmo();
        }

        function update(dt) {
            if (shakeTime > 0) shakeTime -= dt;
            dropTimer += dt * 1000;
            const pct = Math.min(100, (dropTimer / dropInterval) * 100);
            els.timerBar.style.height = `${pct}%`;
            if (dropInterval - dropTimer < 3000) els.effect.classList.add('warning-bg');
            else els.effect.classList.remove('warning-bg');
            if (dropTimer >= dropInterval) {
                dropGrid();
                dropTimer = 0;
                els.effect.classList.remove('warning-bg');
            }
            if (projectile) {
                projectile.x += projectile.vx * dt;
                projectile.y += projectile.vy * dt;
                if (projectile.x - radius < 0 || projectile.x + radius > cw) {
                    projectile.vx *= -1;
                    projectile.x = Math.max(radius, Math.min(cw - radius, projectile.x));
                }
                const ceilingY = gridOffsetY + ceilingRow * tileHeight;
                if (projectile.y - radius < ceilingY) snapProjectile();
                if (projectile) checkCollision();
            }
            particles.forEach((p, i) => {
                p.update(dt);
                if (p.life <= 0) particles.splice(i, 1);
            });
            floatTexts.forEach((t, i) => {
                t.update(dt);
                if (t.life <= 0) floatTexts.splice(i, 1);
            });
        }

        function checkCollision() {
            for (let r = ceilingRow; r < grid.length; r++) { 
                for (let c = 0; c < grid[r].length; c++) {
                    const b = grid[r][c];
                    if (!b) continue;
                    const pos = getBubblePos(r, c);
                    const dist = Math.hypot(projectile.x - pos.x, projectile.y - pos.y);
                    if (dist < radius * 1.8) {
                        snapProjectile();
                        return;
                    }
                }
            }
        }

        function snapProjectile() {
            let bestDist = Infinity;
            let bestR = -1, bestC = -1;
            for (let r = ceilingRow; r < config.rows; r++) {
                const colsInRow = config.cols - ((r + gridOffset) % 2);
                for (let c = 0; c < colsInRow; c++) {
                    if (grid[r][c]) continue; 
                    const pos = getBubblePos(r, c);
                    const dist = Math.hypot(projectile.x - pos.x, projectile.y - pos.y);
                    if (dist < bestDist) {
                        bestDist = dist;
                        bestR = r;
                        bestC = c;
                    }
                }
            }

            if (bestR !== -1) {
                const neighbors = getNeighbors(bestR, bestC);
                let matchedBaseNum = null;
                let matchedColor = -1;
                let isFactor = false;
                let targetNeighbor = null;

                for (let n of neighbors) {
                    const b = grid[n.r][n.c];
                    if (b && b.baseNum && (b.baseNum % projectile.val === 0)) {
                        matchedBaseNum = b.baseNum;
                        matchedColor = b.colorIdx;
                        isFactor = true;
                        targetNeighbor = n;
                        break; 
                    }
                }

                if (isFactor) {
                    const clusterData = getClusterData(targetNeighbor.r, targetNeighbor.c, matchedBaseNum);
                    if (clusterData.values.has(projectile.val)) {
                        playSound('pop'); 
                        addFloatText(projectile.x, projectile.y, "重複!", '#fbbf24', 20);
                        spawnParticles({x: projectile.x, y: projectile.y}, '#fff', 5);
                        projectile = null;
                        currentAmmo = nextAmmo;
                        revalidateAmmo(); 
                        return; 
                    }
                    playSound('transform');
                    grid[bestR][bestC] = {
                        val: projectile.val,
                        baseNum: matchedBaseNum,
                        colorIdx: matchedColor,
                        popAnim: 0
                    };
                    checkFactorCompletion(bestR, bestC, matchedBaseNum);
                } else {
                    playSound('clank');
                    const newColor = Math.floor(Math.random() * config.colors.bubbles.length);
                    grid[bestR][bestC] = {
                        val: projectile.val,
                        baseNum: projectile.val,
                        colorIdx: newColor, 
                        popAnim: 0
                    };
                    els.hint.innerText = `失誤！${projectile.val} 變成了新題目！`;
                    els.hint.className = "mb-4 text-center text-orange-400 font-bold text-sm drop-shadow-md z-10";
                    checkFactorCompletion(bestR, bestC, projectile.val);
                }
            }
            projectile = null;
            currentAmmo = nextAmmo;
            revalidateAmmo();
        }

        function draw() {
            ctx.clearRect(0, 0, cw, ch);
            drawBackground();
            ctx.save();
            if (shakeTime > 0) ctx.translate((Math.random()-0.5)*10, (Math.random()-0.5)*10);

            if (gameState === 'PLAYING') {
                if (isAiming && !projectile) {
                    ctx.beginPath();
                    ctx.moveTo(cannonPos.x, cannonPos.y);
                    const endX = cannonPos.x + Math.cos(aimAngle) * 1000;
                    const endY = cannonPos.y + Math.sin(aimAngle) * 1000;
                    ctx.lineTo(endX, endY);
                    ctx.strokeStyle = config.colors.aimLine;
                    ctx.setLineDash([10, 10]);
                    ctx.lineWidth = 2;
                    ctx.stroke();
                    ctx.setLineDash([]);
                }
                for (let r = 0; r < grid.length; r++) {
                    for (let c = 0; c < grid[r].length; c++) {
                        const b = grid[r][c];
                        if (b) {
                            const pos = getBubblePos(r, c);
                            drawBubble(pos.x, pos.y, b.val, config.colors.bubbles[b.colorIdx], false, b.baseNum);
                        }
                    }
                }
                if (projectile) drawBubble(projectile.x, projectile.y, projectile.val, null, true, null);
                particles.forEach(p => {
                    ctx.globalAlpha = p.life;
                    ctx.fillStyle = p.color;
                    ctx.beginPath(); ctx.arc(p.x, p.y, p.size, 0, Math.PI*2); ctx.fill();
                });
                ctx.globalAlpha = 1;
                floatTexts.forEach(t => {
                    ctx.globalAlpha = t.life;
                    ctx.fillStyle = t.color;
                    ctx.font = 'bold 20px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText(t.text, t.x, t.y);
                    ctx.strokeStyle = 'black'; ctx.lineWidth = 2; ctx.strokeText(t.text, t.x, t.y);
                });
            }
            ctx.restore();
        }

        function drawBackground() {
            const grad = ctx.createLinearGradient(0, 0, 0, ch);
            grad.addColorStop(0, '#0f172a');
            grad.addColorStop(1, '#1e1b4b');
            ctx.fillStyle = grad;
            ctx.fillRect(0, 0, cw, ch);
            ctx.fillStyle = '#fff';
            stars.forEach(s => {
                s.alpha += s.blinkSpeed * s.dir;
                if (s.alpha > 1) { s.alpha = 1; s.dir = -1; }
                else if (s.alpha < 0.2) { s.alpha = 0.2; s.dir = 1; }
                ctx.globalAlpha = s.alpha;
                ctx.beginPath(); ctx.arc(s.x, s.y, s.size, 0, Math.PI * 2); ctx.fill();
            });
            ctx.globalAlpha = 1;
        }

        function getBubblePos(r, c) {
            const offsetX = ((r + gridOffset) % 2 !== 0) ? tileWidth / 2 : 0;
            return {
                x: gridOffsetX + c * tileWidth + radius + offsetX,
                y: gridOffsetY + r * tileHeight + radius
            };
        }

        function drawBubble(x, y, val, color, isRainbow, baseNum) {
            ctx.beginPath();
            ctx.arc(x, y, radius - 1, 0, Math.PI * 2);
            if (isRainbow) {
                const grad = ctx.createRadialGradient(x, y, radius * 0.1, x, y, radius);
                grad.addColorStop(0, '#fff');
                grad.addColorStop(0.3, `hsl(${Date.now() / 5 % 360}, 100%, 50%)`); 
                grad.addColorStop(1, '#000');
                ctx.fillStyle = grad;
            } else {
                const grad = ctx.createRadialGradient(x - radius/3, y - radius/3, radius/5, x, y, radius);
                grad.addColorStop(0, '#fff');
                grad.addColorStop(0.3, color);
                grad.addColorStop(1, '#000');
                ctx.fillStyle = grad;
            }
            ctx.fill();
            ctx.fillStyle = '#fff';
            const fontSize = Math.floor(radius * 1.1); 
            ctx.font = `bold ${fontSize}px 'Noto Sans TC'`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.shadowColor = 'rgba(0,0,0,0.8)';
            ctx.shadowBlur = 4;
            ctx.fillText(val, x, y + 1);
            if (baseNum && val === baseNum) {
                ctx.lineWidth = 3; 
                ctx.strokeStyle = '#fff';
                ctx.beginPath();
                ctx.arc(x, y, radius - 3, 0, Math.PI*2);
                ctx.stroke();
            }
            ctx.shadowBlur = 0;
        }

        function spawnParticles(pos, color, count=8) {
            for(let i=0; i<count; i++) {
                const angle = Math.random() * Math.PI * 2;
                const speed = Math.random() * 80 + 20;
                particles.push({
                    x: pos.x, y: pos.y,
                    vx: Math.cos(angle) * speed, vy: Math.sin(angle) * speed,
                    life: 1.0, color: color, size: Math.random()*3+2,
                    update: function(dt) { this.x += this.vx * dt; this.y += this.vy * dt; this.life -= dt * 2.5; }
                });
            }
        }

        function addFloatText(x, y, text, color, size) {
            floatTexts.push({
                x, y, text, color, size, life: 1.0,
                update: function(dt) { this.y -= 30 * dt; this.life -= dt; }
            });
        }

        function updateUI() {
            els.score.innerText = score;
            els.level.innerText = `${level}/${config.maxLevels}`;
            els.ammo.innerText = currentAmmo;
            els.nextAmmo.innerText = nextAmmo;
        }

        // --- Audio System ---
        function toggleMusic() {
            initAudioContext();
            isMusicPlaying = !isMusicPlaying;
            els.musicBtn.classList.toggle('opacity-50');
            if (isMusicPlaying) startBGM(); else stopBGM();
        }

        function startBGM() {
            if (!audioCtx || audioCtx.state === 'suspended') return;
            if (bgmOscillators.length > 0) return; 
            const freqs = [261.63, 329.63, 392.00, 493.88]; 
            freqs.forEach((f, i) => {
                const osc = audioCtx.createOscillator();
                const gain = audioCtx.createGain();
                osc.type = 'sine';
                osc.frequency.value = f * 0.5; 
                const lfo = audioCtx.createOscillator();
                lfo.frequency.value = 0.1 + (i * 0.05);
                const lfoGain = audioCtx.createGain();
                lfoGain.gain.value = 0.03;
                lfo.connect(lfoGain);
                lfoGain.connect(gain.gain);
                osc.connect(gain);
                gain.connect(audioCtx.destination);
                gain.gain.value = 0.05; 
                osc.start();
                lfo.start();
                bgmOscillators.push({osc, lfo, gain});
            });
        }

        function stopBGM() {
            bgmOscillators.forEach(o => { try { o.osc.stop(); o.lfo.stop(); o.osc.disconnect(); } catch(e){} });
            bgmOscillators = [];
        }

        function playSound(type) {
            if (!audioCtx) initAudioContext();
            if (audioCtx.state === 'suspended') audioCtx.resume();
            if (!audioCtx) return;
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.connect(gain); gain.connect(audioCtx.destination);
            const now = audioCtx.currentTime;
            
            if (type === 'shoot') {
                osc.frequency.setValueAtTime(400, now);
                osc.frequency.exponentialRampToValueAtTime(100, now + 0.15);
                gain.gain.setValueAtTime(0.5, now);
                gain.gain.exponentialRampToValueAtTime(0.01, now + 0.15);
                osc.start(); osc.stop(now+0.15);
            } else if (type === 'pop') {
                osc.frequency.setValueAtTime(600, now);
                osc.frequency.linearRampToValueAtTime(1200, now + 0.1);
                gain.gain.setValueAtTime(0.5, now);
                gain.gain.exponentialRampToValueAtTime(0.01, now + 0.15);
                osc.type = 'triangle';
                osc.start(); osc.stop(now+0.15);
            } else if (type === 'clank') {
                osc.type = 'sawtooth';
                osc.frequency.setValueAtTime(150, now);
                gain.gain.setValueAtTime(0.4, now);
                gain.gain.exponentialRampToValueAtTime(0.01, now + 0.1);
                osc.start(); osc.stop(now+0.1);
            } else if (type === 'drop') {
                osc.type = 'sine';
                osc.frequency.setValueAtTime(200, now);
                osc.frequency.exponentialRampToValueAtTime(50, now + 0.3);
                gain.gain.setValueAtTime(0.5, now);
                gain.gain.exponentialRampToValueAtTime(0.01, now + 0.3);
                osc.start(); osc.stop(now+0.3);
            } else if (type === 'transform') {
                osc.type = 'square';
                osc.frequency.setValueAtTime(400, now);
                osc.frequency.linearRampToValueAtTime(600, now + 0.1);
                gain.gain.setValueAtTime(0.3, now);
                gain.gain.exponentialRampToValueAtTime(0.01, now + 0.1);
                osc.start(); osc.stop(now+0.1);
            } else if (type === 'levelup') {
                osc.type = 'triangle';
                osc.frequency.setValueAtTime(600, now);
                osc.frequency.linearRampToValueAtTime(1200, now + 0.5);
                gain.gain.setValueAtTime(0.5, now);
                gain.gain.exponentialRampToValueAtTime(0.01, now + 0.5);
                osc.start(); osc.stop(now+0.5);
            }
        }

        // --- 遊戲迴圈 (固定在最後) ---
        function gameLoop(timestamp) {
            const dt = Math.min((timestamp - lastTime) / 1000, 0.05);
            lastTime = timestamp;
            if (gameState === 'PLAYING') update(dt);
            draw();
            requestAnimationFrame(gameLoop);
        }
    </script>
</body>
</html>